When we first run the CHA graph, we aquire 12 edges, and locate both Fish and Cat paths.

When we call the PTA (Spark) method (unmodified) instead, however, we aquire an edge total of only 7. This method only traversed the correct Cat path.

This is because of the main fundamental issue with Call Graph Construction, undecidability. It is not possible to determine the exact static call graph, so overapproximations are common. The CHA method is one such overapproximation, chosing to iterate through all possible executions, even some that would never actually execute. However, dispite this, the CHA method uses far fewer hardware resources and far less memory than the alternative. The PTA method, however, conducts a faster, and more accurate pathing. Spark specifically uses the field-sensitive graph on-the-fly algorithm here, by far the most resource intensive of the available options provideded by the framework, to maximize precision. Contrast this to the CHA method, one of the least expensive algorithms to build call graphs, which simply walks the inheritance/ pointer trees and determines what methods are acceptable virtual calls. (Remember, Java makes principally virtual calls). CHA also assumes the entire hierarchy is legal, resulting in that aformentioned overapproximation.